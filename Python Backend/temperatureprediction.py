# -*- coding: utf-8 -*-
"""TemperaturePrediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xg780G1bGXHkuVzXGk7IXrQmNR-FCjA6
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go

from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau

# Load dataset
df = pd.read_csv('Datasets/DailyDelhiClimateTrain.csv')
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Select multiple features
features = ['meantemp', 'humidity', 'wind_speed', 'meanpressure']
data = df[features].values

# Scale data
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

# Create sequences
def create_multivariate_sequences(data, window_size, target_column):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data[i:i + window_size])
        y.append(data[i + window_size, target_column])
    return np.array(X), np.array(y)

window_size = 30  # last 30 days
target_column = 0  # 'meantemp' is the first column
X, y = create_multivariate_sequences(scaled_data, window_size, target_column)

# Train-test split
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Build improved LSTM model
model = Sequential([
    LSTM(128, return_sequences=True, input_shape=(window_size, X.shape[2])),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')

# Callbacks
early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
checkpoint = ModelCheckpoint('best_model.h5', save_best_only=True, monitor='val_loss')
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=1e-5)

# Train model
history = model.fit(
    X_train, y_train,
    validation_data=(X_test, y_test),
    epochs=50,  # increase epochs for better learning
    batch_size=16,
    callbacks=[early_stop, checkpoint, reduce_lr],
    verbose=1
)

# Predict
y_pred = model.predict(X_test)

# Inverse transform: only meantemp column
y_pred_full = np.zeros((len(y_pred), scaled_data.shape[1]))
y_pred_full[:, target_column] = y_pred[:, 0]

y_test_full = np.zeros((len(y_test), scaled_data.shape[1]))
y_test_full[:, target_column] = y_test

y_pred_rescaled = scaler.inverse_transform(y_pred_full)[:, target_column]
y_test_rescaled = scaler.inverse_transform(y_test_full)[:, target_column]

# Dates for plotting
plot_dates = df.index[-len(y_test):]

# Create interactive plot with Plotly
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=plot_dates,
    y=y_test_rescaled,
    mode='lines+markers',
    name='Actual Temperature',
    line=dict(color='blue'),
    hovertemplate='Date: %{x}<br>Actual: %{y:.2f}°C'
))

fig.add_trace(go.Scatter(
    x=plot_dates,
    y=y_pred_rescaled,
    mode='lines+markers',
    name='Predicted Temperature',
    line=dict(color='red'),
    hovertemplate='Date: %{x}<br>Predicted: %{y:.2f}°C'
))

fig.add_annotation(
    x=plot_dates[-1],
    y=y_pred_rescaled[-1],
    text=f"Latest Prediction: {y_pred_rescaled[-1]:.2f}°C",
    showarrow=True,
    arrowhead=2,
    ax=-40,
    ay=-40,
    bgcolor="yellow"
)

fig.update_layout(
    title='Multivariate LSTM Predicted vs Actual Temperature',
    xaxis_title='Date',
    yaxis_title='Mean Temperature (°C)',
    legend=dict(x=0, y=1),
    hovermode='x unified'
)

# fig.show()

# Print last predicted value
print(f"Latest Predicted Temperature: {y_pred_rescaled[-1]:.2f}°C")

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Calculate metrics (rescaled back to original scale)
mse = mean_squared_error(y_test_rescaled, y_pred_rescaled)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_test_rescaled, y_pred_rescaled)
r2 = r2_score(y_test_rescaled, y_pred_rescaled)

print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"R² Score: {r2:.4f}")

import numpy as np

# Get last 29 days from your scaled dataset
last_29_days = scaled_data[-29:, :]  # shape (29, 4)

# Your custom day 30 (scaled!)
custom_input = np.array([[0, 90.0, 6.0, 1020.0]])  # 0 placeholder for meantemp

# Scale the new input (important!)
custom_input_scaled = scaler.transform(custom_input)

# Combine into full 30-day sequence
sequence_input = np.vstack([last_29_days, custom_input_scaled])
sequence_input = sequence_input.reshape(1, 30, 4)  # reshape for LSTM

# Predict
predicted_scaled = model.predict(sequence_input)

# Expand to full feature set for inverse transform
predicted_full = np.zeros((1, scaled_data.shape[1]))
predicted_full[:, 0] = predicted_scaled[:, 0]  # meantemp position

# Inverse transform to get real temp
predicted_temp = scaler.inverse_transform(predicted_full)[:, 0]

print(f"Predicted Temperature: {predicted_temp[0]:.2f}°C")

