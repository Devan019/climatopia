# -*- coding: utf-8 -*-
"""TemperaturePrediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xg780G1bGXHkuVzXGk7IXrQmNR-FCjA6
"""

import pandas as pd
import numpy as np
import xgboost as xgb
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import os

base_path = os.path.dirname(__file__)  # folder of this script
file_path = os.path.join(base_path, 'Datasets', 'DailyDelhiClimateTrain.csv')

df = pd.read_csv(file_path)

df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

# Select multiple features
features = ['meantemp', 'humidity', 'wind_speed', 'meanpressure']
data = df[features].values

# Scale data
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

# Create flattened sequences for XGBoost
def create_xgb_sequences(data, window_size, target_column):
    X, y = [], []
    for i in range(len(data) - window_size):
        window = data[i:i + window_size].flatten()  # shape: window_size * num_features
        X.append(window)
        y.append(data[i + window_size, target_column])
    return np.array(X), np.array(y)

window_size = 30  # last 30 days
target_column = 1  # 'humidity'
X, y = create_xgb_sequences(scaled_data, window_size, target_column)

# Train-test split
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Train XGBoost regressor
model = xgb.XGBRegressor(
    n_estimators=200,
    learning_rate=0.05,
    max_depth=6,
    subsample=0.8,
    colsample_bytree=0.8,
    objective='reg:squarederror',
    random_state=42
)

model.fit(X_train, y_train, eval_set=[(X_test, y_test)],  verbose=True)

# Predict
y_pred_scaled = model.predict(X_test)

# Inverse transform: only meantemp column
y_pred_full = np.zeros((len(y_pred_scaled), scaled_data.shape[1]))
y_pred_full[:, target_column] = y_pred_scaled

y_test_full = np.zeros((len(y_test), scaled_data.shape[1]))
y_test_full[:, target_column] = y_test

y_pred_rescaled = scaler.inverse_transform(y_pred_full)[:, target_column]
y_test_rescaled = scaler.inverse_transform(y_test_full)[:, target_column]

# Dates for plotting
plot_dates = df.index[-len(y_test_rescaled):]

# Calculate metrics
mse = mean_squared_error(y_test_rescaled, y_pred_rescaled)
mae = mean_absolute_error(y_test_rescaled, y_pred_rescaled)
rmse = np.sqrt(mse)
r2 = r2_score(y_test_rescaled, y_pred_rescaled)

print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"R² Score: {r2:.4f}")

# Create interactive plot
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=plot_dates,
    y=y_test_rescaled,
    mode='lines+markers',
    name='Actual Temperature',
    line=dict(color='blue'),
    hovertemplate='Date: %{x}<br>Actual: %{y:.2f}°C'
))

fig.add_trace(go.Scatter(
    x=plot_dates,
    y=y_pred_rescaled,
    mode='lines+markers',
    name='Predicted Temperature',
    line=dict(color='red'),
    hovertemplate='Date: %{x}<br>Predicted: %{y:.2f}°C'
))

fig.add_annotation(
    x=plot_dates[-1],
    y=y_pred_rescaled[-1],
    text=f"Latest Prediction: {y_pred_rescaled[-1]:.2f}°C",
    showarrow=True,
    arrowhead=2,
    ax=-40,
    ay=-40,
    bgcolor="yellow"
)

fig.update_layout(
    title='XGBoost Predicted vs Actual Temperature (Multivariate)',
    xaxis_title='Date',
    yaxis_title='Mean Temperature (°C)',
    legend=dict(x=0, y=1),
    hovermode='x unified'
)

# fig.show()

# Print last predicted value
# print(f"Latest Predicted Temperature: {y_pred_rescaled[-1]:.2f}°C")

# Save model to JSON
model.save_model("xgb_humidity_model.json")
print("✅ XGBoost model saved as JSON.")


